1. Briefly describe your method for preventing the adversary from learning
information about the lengths of the passwords stored in your password manager.
To prevent the adversary from learning information regarding the length of our
passwords, we added additional padding so all passwords would be the same size.
We would pad these passwords up to the maximum size given by the specs sheet.


2. Briefly describe your method for preventing swap attacks (Section 2.2).
Provide an argument for why the attack is prevented in your scheme. To prevent
swap attacks, our password manager cryptographically binds each ciphertext to
its associated domain. When encrypting a password for a domain ùëë (e.g.,
evil.com), the domain is incorporated into the encryption (e.g., as associated
data). During retrieval, decryption is performed using the same domain. If a
ciphertext is swapped with one from a different domain, decryption fails. Thus,
even if an attacker swaps two stored entries, the mismatch between the
ciphertext and the provided domain will be detected, preventing the attack.

3. In our proposed defense against the rollback attack (Section 2.2), we assume
that we can store the SHA-256 hash in a trusted location beyond the reach of an
adversary. Is it necessary to assume that such a trusted location exists, in
order to defend against rollback attacks? Briefly justify your answer. Yes. If
the checksum were stored in the same untrusted place as the dump, an adversary
could perform a consistent rollback: replace both the keychain dump and the
checksum with older versions. The old dump would then verify against the old
checksum, and the rollback would succeed. The defense only works because the
trusted location holds the checksum for the latest state; the adversary cannot
update that checksum when they substitute an older dump, so the verification
fails and the rollback is detected.

4. Because HMAC is a deterministic MAC (that is, its output is the same if it is
run multiple times with the same input), we were able to look up domain names
using their HMAC values. There are also randomized MACs, which can output
different tags on multiple runs with the same input. Explain how you would do
the look up if you had to use a randomized MAC instead of HMAC. Is there a
performance penalty involved, and if so, what?

Using a randomized MAC makes lookup significantly harder because we lose
deterministic tags and therefore lose O(1) lookup. Since the same domain can
produce different MAC outputs each time, we can no longer directly index entries
by their MAC value. Instead, to look up a domain, we would need to iterate over
all stored entries and verify the randomized MAC for each one until a match is
found. This means each lookup would take O(n) time rather than O(1). This is a
major performance decrease, since get is a core operation that many other
functions rely on and is expected to be fast and frequently used.

5. In our specification, we leak the number of records in the password manager.
Describe an approach to reduce the information leaked about the number of
records. Specifically, if there are k records, your scheme should only leak
‚åälog2 (k)‚åã (that is, if k1 and k2 are such that ‚åälog2(k1)‚åã = ‚åälog2(k2)‚åã, the
attacker should not be able to distinguish between a case where the true number
of records is k1 and another case where the true number of records is k2).

6. What is a way we can add multi-user support for specific sites to our
password manager system without compromising security for other sites that these
users may wish to store passwords of? That is, if Alice and Bob wish to access
one stored password (say for nytimes) that either of them can get and update,
without allowing the other to access their passwords for other websites.

In my opinion, one way to add multi-user support is to give each user their own
master key, while allowing shared sites to be encrypted under a shared key. For
example, Alice and Bob can agree on a shared encryption key for nytimes, and
that key is then encrypted separately under Alice‚Äôs key and Bob‚Äôs key. The
actual password for nytimes is stored once, encrypted with the shared key. This
way, both Alice and Bob can decrypt and update the nytimes password using their
own credentials, but neither can access the other‚Äôs passwords for unrelated
websites, since those are encrypted under different keys.
